using Logshark.Helpers;
using Logshark.PluginLib.Model;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using Tableau.RestApi.Models;

namespace Logshark.Controller
{
    public enum ProcessingPhase { Pending, Initializing, Extracting, Parsing, ExecutingPlugins, Complete }

    /// <summary>
    /// Encapsulates state that can be modified throughout the course of a Logshark run.
    /// </summary>
    public class LogsharkRunContext
    {
        // List of Mongo collections generated by this request.
        public ISet<string> CollectionsGenerated { get; protected set; }

        // The current phase that the run is in.
        public ProcessingPhase CurrentPhase { get; internal set; }

        // Track a list of files that we failed to parse any documents from.
        public ICollection<string> FailedFileParses { get; protected set; }

        // Indicates whether the Logshark run was successful or not.
        public bool? IsRunSuccessful { get; internal set; }

        // Indicates whether a logset is valid and able to be parsed by Logshark.
        public bool? IsValidLogset { get; internal set; }

        // Unique hash generated from the target logset.
        public string LogsetHash { get; set; }

        // The product type that the logset for this request covers.
        public LogsetType LogsetType { get; internal set; }

        // The ID of the metadata record associated with this Logshark run.
        public int? MetadataRecordId { get; internal set; }

        // The name of the Mongo database to use.  Defaults to LogsetHash.
        public string MongoDatabaseName { get { return LogsetHash; } }

        // Plugin execution state.
        public ICollection<IPluginResponse> PluginResponses { get; protected set; }

        // The concrete plugin types to execute as a part of this request.
        internal ISet<Type> PluginTypesToExecute { get; set; }

        // Information about any workbooks published to Tableau Server by this request.
        public ICollection<PublishedWorkbookResult> PublishedWorkbooks { get; set; }

        // File location state.
        public string RootLogDirectory { get; set; }

        // If the run failed, this indicates the exception type thrown when it failed.
        public string RunFailureExceptionType { get; internal set; }

        // If the run failed, this indicates the phase it was in when it failed.
        public ProcessingPhase? RunFailurePhase { get; internal set; }

        // If the run failed, this indicates the reason why.
        public string RunFailureReason { get; internal set; }

        // Used to track timing data of various events in processing this request.
        public ConcurrentQueue<TimingData> TimingData { get; protected set; }

        // Indicates whether this Logshark request was able to leverage an existing processed logset from a previous run.
        public bool UtilizedExistingProcessedLogset { get; internal set; }

        public LogsharkRunContext()
        {
            CurrentPhase = ProcessingPhase.Pending;
            LogsetType = LogsetType.Unknown;

            CollectionsGenerated = new HashSet<string>();
            FailedFileParses = new SynchronizedCollection<string>();
            PluginResponses = new List<IPluginResponse>();
            PluginTypesToExecute = new HashSet<Type>();
            PublishedWorkbooks = new List<PublishedWorkbookResult>();
            TimingData = new ConcurrentQueue<TimingData>();
        }

        public LogsharkTimer CreateTimer(string eventName, string eventDetail = "")
        {
            return new LogsharkTimer(this, eventName, eventDetail);
        }

        public void AddTimingData(TimingData timingData)
        {
            TimingData.Enqueue(timingData);
        }

        public double? GetElapsedTime(string eventKey)
        {
            var timingDataDictionary = TimingData.ToDictionary(item => item.Event + item.Detail, item => item);
            if (!timingDataDictionary.ContainsKey(eventKey))
            {
                return null;
            }

            return timingDataDictionary[eventKey].ElapsedSeconds;
        }

        public DateTime? GetStartTime(string eventKey)
        {
            var timingDataDictionary = TimingData.ToDictionary(item => item.Event + item.Detail, item => item);
            if (!timingDataDictionary.ContainsKey(eventKey))
            {
                return null;
            }

            return timingDataDictionary[eventKey].StartTime;
        }

        public void RegisterParseFailure(string parseFailure)
        {
            FailedFileParses.Add(parseFailure);
        }

        public void RegisterPluginResponse(IPluginResponse pluginResponse)
        {
            PluginResponses.Add(pluginResponse);
        }
    }
}